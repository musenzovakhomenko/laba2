= Отчет по лабораторной работе №2

a)

1.Создадим проект в IAR Workbench, аналогично алгоритму приведенному в
отчете по лабораторной работе №1.

2.Создадим глобальную переменную типа
unsigned short и присвоим ей значение 65535.

3.В функции main добавим к переменной 1 и запустим программу.
Произведем пошаговую компиляцию и выведем результат работы программы
в окне Terminal I/O. Сначала программа выводит
значение переменной, а затем выполняет операцию сложения, в
ходе которой в терменале появляется результат вычисления равный 0.
Это противоречит законам арифметики. Это происходит из-за того, что диапазон
значений которые принимает переменная unsigned char варьируется от 0 до 65535.
После этого проиходит переполнение переменной и отсчет начинается с начала
 то есть с 0, что мы и можем видеть в результате задания.

image::https://github.com/musenzovakhomenko/laba2/blob/main/11.jpg[]

4.Поменяем тип переменной на sighed short и присвоем ей значение 32767.

5.В функции main  добавим к переменной типа sighed short единицу и запустим
программу. Проводя пошаговую отладку  после действия сложения  в Terminal I/O
выводится значение -32768.  Так как переменная типа sighed short может
принимать значения  от -32768 до 32767, то при пибавлении единицы
происходит переполнение и отсчет начинается с начала диапазона.

image::https://github.com/musenzovakhomenko/laba2/blob/main/22.jpg[]

6.Не меняя тип переменной с помощью оператора & в Terminal I/O
выведем адрес, где храниться наша переменная.

image::https://github.com/musenzovakhomenko/laba2/blob/main/33.jpg[]

7.Не меняя тип переменной явно преобразуем адрес переменной
к типу указатель на short.  Для этого была использованна функция
reinterpret_cast. Для удобства выполнения задания воспользуемся
псевдонимами типов, в котором с помощью переменной tMyVar определим переменную
myVar типа short.

8.После запуска программы и пошаговой отладке в Terminal I/O записывается значение,
которое присвоенно нашей переменной и адрес по которому располагается наша
переменная.

9.Разыменуем указатель на переменную и выведем в Terminal I/O
значение лежащее по адресу указанному в указателе.Таким образом действие выполнено
правильно, так как значение , которое храниться в переменной и
и переменная, которая выводится по адресу совпадают.

image::https://github.com/musenzovakhomenko/laba2/blob/main/44.jpg[]

10.Сделаем явное преобразование к типу указателя на int и выведем полученное
значение.Значение выведенное после преобразования поменяло знак и стало
равным 32768. Арифметическое действие выполнено верно.
Это связанно с тем, что полученное число входит в
диапазон значений типа int.

image::https://github.com/musenzovakhomenko/laba2/blob/main/55.jpg[]

б)

1.Заменим тип переменной на short  и присвоим ей значение 65535.

2.В функции main выведем значение нашей переменнной. В результате выводится
значение -1, это означает , что переменная переполнена и происходит смена знака.

image::https://github.com/musenzovakhomenko/laba2/blob/main/66.jpg[]

3.Сделаем явное преобразование типа к short . В результате также получили -1.
Так ка выполнили преобразование к такому же типу.

image::https://github.com/musenzovakhomenko/laba2/blob/main/77.jpg[]

в)

1.Создадим переменную типа float и присвоим ей значение 40'000'000'000.0F.

2.Прибавим к этому значению 1.0f и выведем это значение в окно Watch. Полученный
результат можно объяснить тем, что тип float не имеет достаточной
точности, чтобы показать относительно малые изменения чисел.

image::https://github.com/musenzovakhomenko/laba2/blob/main/88.jpg[]

3.Заменим тип переменной float на double.

4.Прибавим к этому значению 1.0f и выведем это значение в окно Watch. Полученный
результат можно объяснить тем, что переменная типа double может вывести результат
с необходимой точностью, что мы можем увидеть на рисунке ниже.

image::https://github.com/musenzovakhomenko/laba2/blob/main/99.jpg[]





